Index: app/src/main/AndroidManifest.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    xmlns:tools=\"http://schemas.android.com/tools\">\r\n\r\n    <uses-feature android:name=\"android.hardware.camera.any\" />\r\n\r\n    <uses-permission android:name=\"android.permission.CAMERA\" />\r\n    <uses-permission android:name=\"android.permission.RECORD_AUDIO\" />\r\n    <uses-permission android:name=\"android.permission.PREVENT_POWER_KEY\" />\r\n    <uses-permission\r\n        android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"\r\n        android:maxSdkVersion=\"28\" />\r\n    <uses-permission android:name=\"android.permission.WAKE_LOCK\" />\r\n\r\n    <application\r\n        android:allowBackup=\"true\"\r\n        android:dataExtractionRules=\"@xml/data_extraction_rules\"\r\n        android:fullBackupContent=\"@xml/backup_rules\"\r\n        android:icon=\"@mipmap/ic_launcher\"\r\n        android:label=\"@string/app_name\"\r\n        android:supportsRtl=\"true\"\r\n        android:theme=\"@style/Theme.CameraAPIs\"\r\n        tools:targetApi=\"31\">\r\n        <activity\r\n            android:name=\".PermissionDenyActivity\"\r\n            android:exported=\"false\" />\r\n        <activity\r\n            android:name=\".SettingsActivity\"\r\n            android:exported=\"false\"\r\n            android:label=\"@string/title_activity_settings\" />\r\n        <activity\r\n            android:name=\".MainActivity\"\r\n            android:exported=\"true\"\r\n            android:screenOrientation=\"portrait\">\r\n            <intent-filter>\r\n                <action android:name=\"android.intent.action.MAIN\" />\r\n\r\n                <category android:name=\"android.intent.category.LAUNCHER\" />\r\n            </intent-filter>\r\n        </activity>\r\n\r\n    </application>\r\n\r\n</manifest>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/AndroidManifest.xml b/app/src/main/AndroidManifest.xml
--- a/app/src/main/AndroidManifest.xml	(revision c5b2c0d6a946c923406dc2cf75102b84d5fc6160)
+++ b/app/src/main/AndroidManifest.xml	(date 1686245405960)
@@ -38,6 +38,10 @@
                 <category android:name="android.intent.category.LAUNCHER" />
             </intent-filter>
         </activity>
+        <activity android:name=".ScannerCaptureActivity"
+            android:screenOrientation="portrait"
+            android:stateNotNeeded="true"
+            android:theme="@style/zxing_CaptureTheme" />
 
     </application>
 
Index: app/src/main/java/com/unipd/cameraapis/MainActivity.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.unipd.cameraapis\r\n\r\nimport android.Manifest\r\nimport android.app.Activity\r\nimport android.content.ContentValues\r\nimport android.content.Context\r\nimport android.content.Intent\r\nimport android.content.pm.PackageManager\r\nimport android.database.Cursor\r\nimport android.graphics.Rect\r\nimport android.hardware.camera2.CameraManager\r\nimport android.net.Uri\r\nimport android.os.Bundle\r\nimport android.os.CountDownTimer\r\nimport android.os.Handler\r\nimport android.os.SystemClock\r\nimport android.provider.MediaStore\r\nimport android.util.DisplayMetrics\r\nimport android.util.Log\r\nimport android.util.Rational\r\nimport android.view.GestureDetector\r\nimport android.view.HapticFeedbackConstants\r\nimport android.view.KeyEvent\r\nimport android.view.Menu\r\nimport android.view.MenuItem\r\nimport android.view.MotionEvent\r\nimport android.view.OrientationEventListener\r\nimport android.view.ScaleGestureDetector\r\nimport android.view.View\r\nimport android.view.WindowManager\r\nimport android.view.animation.Animation\r\nimport android.view.animation.AnimationUtils\r\nimport android.widget.Button\r\nimport android.widget.Chronometer\r\nimport android.widget.SeekBar\r\nimport android.widget.TextView\r\nimport android.widget.Toast\r\nimport androidx.activity.result.contract.ActivityResultContracts\r\nimport androidx.appcompat.app.AppCompatActivity\r\nimport androidx.camera.core.AspectRatio\r\nimport androidx.camera.core.CameraControl\r\nimport androidx.camera.core.CameraInfo\r\nimport androidx.camera.core.CameraSelector\r\nimport androidx.camera.core.FocusMeteringAction\r\nimport androidx.camera.core.ImageCapture\r\nimport androidx.camera.core.ImageCaptureException\r\nimport androidx.camera.core.Preview\r\nimport androidx.camera.core.impl.ImageCaptureConfig\r\nimport androidx.camera.lifecycle.ProcessCameraProvider\r\nimport androidx.camera.video.MediaStoreOutputOptions\r\nimport androidx.camera.video.Quality\r\nimport androidx.camera.video.QualitySelector\r\nimport androidx.camera.video.Recorder\r\nimport androidx.camera.video.Recording\r\nimport androidx.camera.video.VideoCapture\r\nimport androidx.camera.video.VideoRecordEvent\r\nimport androidx.camera.video.impl.VideoCaptureConfig\r\nimport androidx.constraintlayout.widget.ConstraintLayout\r\nimport androidx.constraintlayout.widget.Group\r\nimport androidx.core.app.ActivityCompat\r\nimport androidx.core.content.ContextCompat\r\nimport androidx.core.content.PermissionChecker\r\nimport androidx.preference.PreferenceManager\r\nimport com.unipd.cameraapis.databinding.ActivityMainBinding\r\nimport kotlinx.coroutines.CoroutineScope\r\nimport kotlinx.coroutines.Dispatchers\r\nimport kotlinx.coroutines.Job\r\nimport kotlinx.coroutines.delay\r\nimport kotlinx.coroutines.isActive\r\nimport kotlinx.coroutines.launch\r\nimport java.text.SimpleDateFormat\r\nimport java.util.Locale\r\nimport java.util.concurrent.ExecutorService\r\nimport java.util.concurrent.Executors\r\nimport kotlin.math.abs\r\n\r\nclass MainActivity : AppCompatActivity() {\r\n\r\n    private lateinit var viewBinding: ActivityMainBinding\r\n\r\n    private var imageCapture: ImageCapture? = null\r\n\r\n    private var videoCapture: VideoCapture<Recorder>? = null\r\n    private var recording: Recording? = null\r\n\r\n    private lateinit var cameraExecutor: ExecutorService\r\n\r\n    // Select back camera as a default\r\n    private var cameraSelector = CameraSelector.DEFAULT_BACK_CAMERA\r\n\r\n    // Widget di activity_main.xml\r\n    private lateinit var btFlash : Button\r\n    private lateinit var btGallery : Button\r\n    private lateinit var btPause : Button\r\n    private lateinit var btPhotoMode : Button\r\n    private lateinit var btRecMode : Button\r\n    private lateinit var btRotation : Button\r\n    private lateinit var btShoot : Button\r\n    private lateinit var btStop : Button\r\n    private lateinit var btTimer : Button\r\n    private lateinit var btZoom05 : Button\r\n    private lateinit var btZoom10 : Button\r\n    private lateinit var btZoomRec : Button\r\n    private lateinit var btQR : Button\r\n    private lateinit var btSettings : Button\r\n    private lateinit var focusCircle : View\r\n    private lateinit var focusView : View\r\n    private lateinit var viewPreview : View\r\n    private lateinit var sbZoom : SeekBar\r\n    private lateinit var cmRecTimer : Chronometer\r\n    private lateinit var countDownText : TextView\r\n\r\n    // variabili\r\n    private lateinit var availableCameraInfos: MutableList<CameraInfo>\r\n    private lateinit var camera : androidx.camera.core.Camera\r\n    private lateinit var cameraControl: CameraControl\r\n    private lateinit var cameraManager : CameraManager\r\n    private lateinit var cameraProvider: ProcessCameraProvider\r\n    private lateinit var preview: Preview\r\n    private lateinit var recorder: Recorder\r\n    private lateinit var scaleDown: Animation\r\n    private lateinit var gestureDetector: GestureDetector\r\n    private lateinit var scaleGestureDetector: ScaleGestureDetector\r\n    private lateinit var scaleUp: Animation\r\n    private lateinit var timer: CountDownTimer\r\n    private var volumeTimer: CountDownTimer? = null\r\n\r\n    private val changeCameraSeekBar = 50\r\n    private var cmPauseAt : Long = 0\r\n    private var countdown : Long = 0\r\n    private var currFlashMode : FlashModes = FlashModes.OFF\r\n    private var currTimerMode : TimerModes = TimerModes.OFF\r\n    private var currentCamera = 0\r\n    // 0 -> back default;   grand angolare\r\n    // 1 -> front default;  ultra grand angolare\r\n    // 2 -> back;           ultra grand angolare\r\n    // 3 -> front;          grand angolare\r\n    private var zoomLv : Float = 0.toFloat() // va da 0 a 1\r\n    private var countMultiShot = 0\r\n\r\n    private var recordMode = false\r\n    private var isRecording = false\r\n    private var inPause = false\r\n    private var timerOn = false\r\n    private var qrScanner = true\r\n    private var captureJob: Job? = null\r\n    private var isbtShootLongClicked = false\r\n    private var isVolumeButtonClicked : Boolean = false\r\n\r\n    private lateinit var volumeKey : String\r\n    private lateinit var aspectRatioPhoto : Rational\r\n    private lateinit var aspectRatioVideo : Rational\r\n    private var ratioVideo = AspectRatio.RATIO_4_3\r\n    private var videoResolution = QualitySelector.from(Quality.HIGHEST)\r\n    private var hdr = true\r\n    private var gps = false\r\n    private var feedback = true\r\n\r\n    private var savedBundle: Bundle? = null\r\n    private val showPopUp = PopUpFragment()\r\n    private var popUpVisible = false\r\n    private var permissionDenyAsk = false\r\n\r\n    companion object {\r\n\r\n        private const val TAG = \"CameraXApp\"\r\n        private const val FILENAME_FORMAT = \"yyyy-MM-dd_HH-mm-ss-SSS\"\r\n        private const val REQUEST_CODE_PERMISSIONS = 10\r\n\r\n        private const val KEY_CAMERA = \"CurrentCamera\"\r\n        private const val KEY_FLASH = \"FlashMode\"\r\n        private const val KEY_TIMER = \"TimerMode\"\r\n        private const val KEY_ZOOM = \"ZoomProgress\"\r\n        private const val KEY_REC = \"RecordMode\"\r\n        private const val KEY_QRCODE = \"qrScanner\"\r\n\r\n        private const val TOUCH_THRESHOLD = 0.1\r\n\r\n        private const val LONGCLICKDURATION = 300L\r\n\r\n        private const val DOUBLE_CLICK_DELTA_TIME : Long = 300      // Tempo entro il quale viene rilevato il doppio tocco\r\n\r\n        private val REQUIRED_PERMISSIONS =\r\n            mutableListOf (\r\n                Manifest.permission.CAMERA,\r\n                Manifest.permission.RECORD_AUDIO\r\n            ).apply {\r\n            }.toTypedArray()\r\n    }\r\n\r\n    /**\r\n     * Todo commento\r\n     */\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        viewBinding = ActivityMainBinding.inflate(layoutInflater)\r\n        setContentView(viewBinding.root)\r\n\r\n        savedBundle = savedInstanceState\r\n\r\n        createElement() // inizializza le variabili\r\n\r\n        // Controlla se sono stati forniti i permessi\r\n        if (allPermissionsGranted())\r\n            startCamera()\r\n        else\r\n            askPermission()\r\n\r\n        //Todo ???? che fa?\r\n        cameraExecutor = Executors.newSingleThreadExecutor()\r\n    }\r\n\r\n    fun askPermission() {\r\n        ActivityCompat.requestPermissions(this, REQUIRED_PERMISSIONS, REQUEST_CODE_PERMISSIONS)\r\n        Log.d(TAG, \"Permission asked\")\r\n    }\r\n\r\n    /**\r\n     * TODO: da commentare\r\n     */\r\n    fun allPermissionsGranted() = REQUIRED_PERMISSIONS.all {\r\n        ContextCompat.checkSelfPermission(baseContext, it) == PackageManager.PERMISSION_GRANTED\r\n    }\r\n\r\n    /**\r\n     * TODO: da commentare\r\n     */\r\n    override fun onRequestPermissionsResult(requestCode: Int, permissions: Array<String>, grantResults: IntArray) {\r\n        super.onRequestPermissionsResult(requestCode, permissions, grantResults)\r\n        if (requestCode == REQUEST_CODE_PERMISSIONS) {\r\n            if (allPermissionsGranted()) {\r\n                startCamera()\r\n            }\r\n            else if(permissionDenyAsk)\r\n            {\r\n                val intent = Intent(this, PermissionDenyActivity::class.java)\r\n                startActivityForResult(intent, 0)\r\n            }\r\n            else if(!popUpVisible) // limita le apperture delle schede\r\n            {\r\n                showPopUp.show(supportFragmentManager, \"showPopUp\")\r\n                showPopUp.onDismissListener = {\r\n                    popUpVisible = false\r\n                    if (allPermissionsGranted())\r\n                        startCamera()\r\n                    else {\r\n                        val intent = Intent(this, PermissionDenyActivity::class.java)\r\n                        startActivityForResult(intent, 0)\r\n                    }\r\n                }\r\n                popUpVisible = true\r\n            }\r\n        }\r\n        Log.d(TAG, \"Permission Request\")\r\n    }\r\n\r\n    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {\r\n        super.onActivityResult(requestCode, resultCode, data)\r\n\r\n        if (resultCode == 1)\r\n        {\r\n            permissionDenyAsk = true\r\n            askPermission()\r\n        }\r\n        else\r\n            finish()\r\n    }\r\n\r\n    override fun onWindowFocusChanged(hasFocus: Boolean) {\r\n        super.onWindowFocusChanged(hasFocus)\r\n        if (hasFocus) {\r\n            val preferences = getPreferences(MODE_PRIVATE)\r\n\r\n            // recupero le variabili dalle preferences\r\n            var hB = preferences.getInt(\"bottomBandHeight\", -1)\r\n            var hT = preferences.getInt(\"topBandHeight\", -1)\r\n\r\n            Log.d(TAG, \"height bottom $hB\")\r\n            Log.d(TAG, \"height top $hT\")\r\n\r\n            var bottomBand = findViewById<View>(R.id.VW_bottomBand)\r\n            var topBand = findViewById<View>(R.id.VW_topBand)\r\n            val layoutParamsB = bottomBand.layoutParams\r\n            val layoutParamsT = topBand.layoutParams\r\n\r\n            if (hB == -1) // primo avvio del app\r\n            {\r\n                val displayMetrics = DisplayMetrics()\r\n                windowManager.defaultDisplay.getMetrics(displayMetrics)\r\n                val height = displayMetrics.heightPixels\r\n\r\n                hB = height - viewPreview.bottom // Imposta l'altezza desiderata in pixel\r\n                hT = viewPreview.top // Imposta l'altezza desiderata in pixel\r\n\r\n                val editor = preferences.edit()\r\n                editor.putInt(\"bottomBandHeight\", hB)\r\n                editor.putInt(\"topBandHeight\", hT)\r\n                editor.apply()\r\n            }\r\n\r\n            layoutParamsB.height = hB\r\n            bottomBand.layoutParams = layoutParamsB\r\n\r\n            layoutParamsT.height = hT\r\n            topBand.layoutParams = layoutParamsT\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Funzione per istanziare elementi del activity_main.xml;\r\n     * assagnazione dei widget e altre variabili\r\n     */\r\n    private fun createElement()\r\n    {\r\n        btFlash = viewBinding.BTFlash\r\n        btGallery = viewBinding.BTGallery\r\n        btPause = viewBinding.BTPause\r\n        btPhotoMode = viewBinding.BTPhotoMode\r\n        btRecMode = viewBinding.BTRecordMode\r\n        btRotation = viewBinding.BTRotation\r\n        btShoot = viewBinding.BTShoots\r\n        btStop = viewBinding.BTStop\r\n        btTimer = viewBinding.BTTimer\r\n        btZoom05 = viewBinding.BT05\r\n        btZoom10 = viewBinding.BT10\r\n        btZoomRec = viewBinding.BTZoomRec\r\n        btQR = viewBinding.BTQrcode\r\n        btSettings = viewBinding.BTSettings\r\n        cmRecTimer = viewBinding.CMRecTimer\r\n        cmRecTimer.format = \"%02d:%02d:%02d\"\r\n        focusCircle = viewBinding.FocusCircle\r\n        sbZoom = viewBinding.SBZoom\r\n        countDownText = viewBinding.TextTimer\r\n        focusView = viewBinding.FocusCircle\r\n        viewPreview = viewBinding.viewPreview\r\n\r\n        scaleDown = AnimationUtils.loadAnimation(this,R.anim.scale_down)\r\n        scaleUp = AnimationUtils.loadAnimation(this,R.anim.scale_up)\r\n\r\n        gestureDetector = GestureDetector(this, MyGestureListener())\r\n        scaleGestureDetector = ScaleGestureDetector(this, ScaleGestureListener())\r\n\r\n    }\r\n\r\n    /**\r\n     * Funzione per l'assegnazione dei Listener ai widget\r\n     * Todo: da finire di commentare\r\n     */\r\n    private fun createListener()\r\n    {\r\n        //Con un click sul pulsante si passa alla modalità successiva del flash\r\n        btFlash.setOnClickListener { switchFlashMode() }\r\n        /*Con un click prolungato si apre un menù contestuale che permette di selezionare una\r\n          specifica modalità del flash*/\r\n        btFlash.setOnCreateContextMenuListener { menu, _, _ ->\r\n            menu.setHeaderTitle(\"Flash\")\r\n            for(mode in FlashModes.values()) {\r\n                val item: MenuItem = menu.add(Menu.NONE, mode.ordinal, Menu.NONE, mode.text)\r\n                item.setOnMenuItemClickListener { i: MenuItem? ->\r\n                    selectFlashMode(i?.itemId)\r\n                    true // Signifies you have consumed this event, so propogation can stop.\r\n                }\r\n            }\r\n        }\r\n        //Con un click sul pulsante di apre la galleria\r\n        btGallery.setOnClickListener{\r\n            val uriExternal: Uri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI\r\n\r\n            val projection = arrayOf(\r\n                MediaStore.Images.ImageColumns._ID,\r\n                MediaStore.Images.Media._ID,\r\n                MediaStore.Images.ImageColumns.DATE_ADDED,\r\n                MediaStore.Images.ImageColumns.MIME_TYPE\r\n            )\r\n            val cursor: Cursor = applicationContext.contentResolver.query(uriExternal, projection, null,\r\n                null, MediaStore.Images.ImageColumns.DATE_ADDED + \" DESC\"\r\n            )!!\r\n\r\n            Log.i(\"Cursor Last\", cursor.moveToLast().toString())\r\n            if (cursor.moveToFirst()) {\r\n                val columnIndexID = cursor.getColumnIndexOrThrow(MediaStore.Images.Media._ID)\r\n                val imageId: Long = cursor.getLong(columnIndexID)\r\n                val imageURI = Uri.withAppendedPath(uriExternal, \"\" + imageId)\r\n                val intent = Intent()\r\n                intent.action = Intent.ACTION_VIEW\r\n                intent.setDataAndType(imageURI, \"image/*\")\r\n                startActivity(intent)\r\n            }\r\n\r\n            cursor.close()\r\n        }\r\n\r\n        btPause.setOnClickListener{ pauseVideo() }\r\n        btPhotoMode.setOnClickListener { changeMode(false) }\r\n        btRecMode.setOnClickListener { changeMode(true) }\r\n        btRotation.setOnClickListener {\r\n            rotateCamera()\r\n            if(feedback) it.performHapticFeedback(HapticFeedbackConstants.CONFIRM)\r\n        }\r\n\r\n        btShoot.setOnTouchListener { _, event ->\r\n            if (event.action == MotionEvent.ACTION_UP) {\r\n                captureJob?.cancel()\r\n                captureJob = null\r\n                countDownText.postDelayed(Runnable {\r\n                    countDownText.visibility = View.INVISIBLE\r\n                }, 1000)\r\n                true\r\n            }\r\n            false\r\n        }\r\n\r\n        btShoot.setOnClickListener {\r\n            timerShot(recordMode)\r\n            if(feedback) it.performHapticFeedback(HapticFeedbackConstants.CONFIRM)\r\n        }\r\n        \r\n        btShoot.setOnLongClickListener{\r\n            if (recordMode) {\r\n                timerShot(true)\r\n                if(feedback) it.performHapticFeedback(HapticFeedbackConstants.CONFIRM)\r\n            } else {\r\n                countMultiShot = 0\r\n                countDownText.visibility = View.VISIBLE\r\n                captureJob = CoroutineScope(Dispatchers.Main).launch {\r\n                    while (isActive) {\r\n                        takePhoto()\r\n                        countDownText.text = \"${++countMultiShot}\"\r\n                        delay(300) // Intervallo tra i singoli scatti\r\n                        if (feedback) it.performHapticFeedback(HapticFeedbackConstants.CONFIRM)\r\n                    }\r\n                }\r\n            }\r\n            true // Restituisce true per indicare che l'evento di click lungo è stato gestito correttamente\r\n        }\r\n\r\n        btStop.setOnClickListener{\r\n            timerShot(recordMode)\r\n        }\r\n        btTimer.setOnClickListener { switchTimerMode() }\r\n        btTimer.setOnCreateContextMenuListener { menu, _, _ ->\r\n            menu.setHeaderTitle(\"Timer\")\r\n            for(mode in TimerModes.values()) {\r\n                val item: MenuItem = menu.add(Menu.NONE, mode.ordinal, Menu.NONE, mode.text)\r\n                item.setOnMenuItemClickListener { i: MenuItem? ->\r\n                    selectTimerMode(i?.itemId)\r\n                    true // Signifies you have consumed this event, so propogation can stop.\r\n                }\r\n            }\r\n        }\r\n\r\n        btZoom10.setOnClickListener { sbZoom.progress = changeCameraSeekBar }\r\n        btZoom05.setOnClickListener{ sbZoom.progress = 0 }\r\n        sbZoom.setOnSeekBarChangeListener(object : SeekBar.OnSeekBarChangeListener {\r\n            override fun onProgressChanged(seekBar: SeekBar?, progress: Int, fromUser: Boolean) {\r\n                changeZoom(progress)\r\n                if(feedback && progress%5 == 0 && fromUser) // ogni 5 do un feedback, e solo se muovo manualmente la SB\r\n                    sbZoom.performHapticFeedback(HapticFeedbackConstants.CLOCK_TICK)\r\n            }\r\n            override fun onStartTrackingTouch(seek: SeekBar) = Unit\r\n            override fun onStopTrackingTouch(seek: SeekBar) = Unit\r\n        })\r\n\r\n        /*Con un click sulla view che contiene la preview della camera si può spostare il focus su\r\n          una specifica zona*/\r\n\r\n        viewPreview.setOnTouchListener(View.OnTouchListener setOnTouchListener@{ _, event ->\r\n            gestureDetector.onTouchEvent(event)\r\n            scaleGestureDetector.onTouchEvent(event)\r\n            true\r\n        })\r\n\r\n\r\n        // listener per il pulsante QR\r\n        btQR.setOnClickListener {\r\n            qrScanner = !qrScanner\r\n            qrCode(qrScanner)\r\n\r\n            //Todo: butta dentro QrCode plz, che lo richiamo dal loadBundle\r\n            //Todo: inoltre prima di mostrare risultati contollare che il timer sia disattivato, -> \"timerOn\"\r\n\r\n            /*\r\n            val intentIntegrator = IntentIntegrator(this)\r\n            intentIntegrator.setDesiredBarcodeFormats(IntentIntegrator.QR_CODE)\r\n            intentIntegrator.setOrientationLocked(true)\r\n            intentIntegrator.setPrompt(\"Scanning\")\r\n            intentIntegrator.initiateScan()\r\n            */\r\n\r\n        }\r\n\r\n        btSettings.setOnClickListener {view ->\r\n            startActivity(Intent(view.context, SettingsActivity::class.java))\r\n        }\r\n\r\n    }\r\n\r\n    private fun qrCode(status: Boolean)\r\n    {\r\n        if(status)\r\n            btQR.backgroundTintList = getColorStateList(R.color.aureolin_yellow)\r\n        else\r\n            btQR.backgroundTintList = getColorStateList(R.color.white)\r\n    }\r\n\r\n    /**\r\n     * Ricostruisce la camera\r\n     */\r\n    private fun buildCamera()\r\n    {\r\n        cameraSelector =\r\n            try { // dato che uso gli id della mia camera allora potrebbe non esistere qulla camera\r\n                availableCameraInfos[currentCamera].cameraSelector\r\n            } catch (e : Exception) {\r\n                if (currentCamera % 2 == 0) // se è camera 0 o 2 è back\r\n                    CameraSelector.DEFAULT_BACK_CAMERA\r\n                else\r\n                    CameraSelector.DEFAULT_FRONT_CAMERA\r\n            }\r\n        try {\r\n            cameraProvider.unbindAll()            // Unbind use cases before rebinding\r\n            camera = cameraProvider.bindToLifecycle(this, cameraSelector, preview, imageCapture, videoCapture) // devo ricostruire la camera ogni volta, dato che cambio al camera\r\n            // in quato cambio la camera\r\n            cameraControl = camera.cameraControl\r\n        } catch(e: Exception) {\r\n            Log.e(TAG, \"Build failed\", e)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Crea la Preview della fotocamera e ne seleziona l'output, seleziona l'aspect ratio e la qualità video\r\n     */\r\n    private fun startCamera() {\r\n        // si ottiene un'istanza di tipo ListenableFuture che rappresenta un'istanza di ProcessCameraProvider, disponibile in seguito\r\n        // permette di recuperare l'istanza di ProcessCameraProvider in modo asincrono\r\n        val cameraProviderFuture = ProcessCameraProvider.getInstance(this)\r\n\r\n        cameraProviderFuture.addListener({\r\n            // recupera l'istanza di ProcessCameraProvider\r\n            cameraProvider = cameraProviderFuture.get()\r\n\r\n            // crea la Preview\r\n            preview = Preview.Builder()\r\n                .build()    // creo l'istanza di Preview\r\n                .also {\r\n                    it.setSurfaceProvider(viewBinding.viewPreview.surfaceProvider)  // seleziono dove visualizzare la preview\r\n                }\r\n\r\n            // costruita un'istanza di Recorder\r\n            createRecorder()\r\n\r\n            // crea un'istanza di ImageCapture e imposta il flash a OFF\r\n            imageCapture = ImageCapture.Builder().setFlashMode(ImageCapture.FLASH_MODE_OFF).build()\r\n\r\n            // seleziona la fotocamera dorsale di default\r\n            cameraSelector = CameraSelector.DEFAULT_BACK_CAMERA\r\n\r\n            // Crea un oggetto CameraSelector per la fotocamera ultra grandangolare\r\n            availableCameraInfos = cameraProvider.availableCameraInfos\r\n            Log.i(TAG, \"[startCamera] available cameras Info:$availableCameraInfos\")\r\n            cameraManager = getSystemService(Context.CAMERA_SERVICE) as CameraManager\r\n            val availableCamera : Array<String> = cameraManager.cameraIdList    // lista contenente le fotocamere del dispositivo\r\n            Log.i(TAG, \"[startCamera] available cameras:${availableCamera}\")\r\n\r\n            try {\r\n                createListener() // crea i Listener\r\n                buildCamera()\r\n                loadFromBundle(savedBundle) // carica gli elementi dal Bundle/Preferences\r\n                setFlashMode() // non so perchè ma se lo lascio al interno di loadFromBundle, viene modificato ma successivamente perde lo stato\r\n            } catch(exc: Exception) {\r\n                Log.e(TAG, \"Use case binding failed\", exc)\r\n            }\r\n\r\n        }, ContextCompat.getMainExecutor(this)) // specifica che le operazioni del listener vengano eseguite nel thread principale\r\n    }\r\n\r\n    private fun createRecorder() {\r\n        try {\r\n            recorder = Recorder.Builder()\r\n                .setQualitySelector(videoResolution)    // qualità video\r\n                .setAspectRatio(ratioVideo)             // aspect ratio\r\n                .build()\r\n            videoCapture = VideoCapture.withOutput(recorder)    // crea un oggetto di tipo VideoCapture e imposto record come output video\r\n        }\r\n        catch ( e : Exception)\r\n        {\r\n            Log.e(TAG, \"[createRecorder]\", e)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Metodo per scattare una foto usando le impostazioni di [imageCapture]\r\n     */\r\n    private fun takePhoto() {\r\n        //Log.d(TAG,\"ClickListener\")\r\n        // Get a stable reference of the modifiable image capture use case\r\n        val imageCapture = imageCapture ?: return\r\n        // Create time stamped name and MediaStore entry.\r\n        val name = SimpleDateFormat(FILENAME_FORMAT, Locale.US)\r\n            .format(System.currentTimeMillis())\r\n        val contentValues = ContentValues().apply {\r\n            put(MediaStore.MediaColumns.DISPLAY_NAME, name)\r\n            put(MediaStore.MediaColumns.MIME_TYPE, \"image/jpeg\")\r\n\r\n            //put(MediaStore.Images.Media.RELATIVE_PATH, \"Pictures/CameraX-Image\")\r\n            put(MediaStore.Images.Media.RELATIVE_PATH, \"DCIM/CameraAPIs\")\r\n        }\r\n\r\n        // Create output options object which contains file + metadata\r\n        val outputOptions = ImageCapture.OutputFileOptions\r\n            .Builder(contentResolver,\r\n                MediaStore.Images.Media.EXTERNAL_CONTENT_URI,\r\n                contentValues)\r\n            .build()\r\n\r\n        // Set up image capture listener, which is triggered after photo has\r\n        // been taken\r\n        btShoot.startAnimation(scaleDown)\r\n        viewPreview.startAnimation(scaleUp)\r\n        imageCapture.takePicture( // caso d'uso\r\n            outputOptions,\r\n            ContextCompat.getMainExecutor(this),\r\n            object : ImageCapture.OnImageSavedCallback {\r\n\r\n                override fun onError(exc: ImageCaptureException) {\r\n                    Log.e(TAG, \"Photo capture failed: ${exc.message}\", exc)\r\n                }\r\n\r\n                override fun onImageSaved(output: ImageCapture.OutputFileResults){\r\n                    /*val msg = \"Photo capture succeeded: ${output.savedUri}\"\r\n                    Toast.makeText(baseContext, msg, Toast.LENGTH_SHORT).show()\r\n                    Log.d(TAG, msg)*/\r\n                }\r\n            }\r\n        )\r\n        btTimer.visibility = View.VISIBLE   //rendo di nuovo visibile il pulsante del timer dopo aver scattato la foto\r\n    }\r\n\r\n    /**\r\n     * TODO: commentare e sistemare\r\n     *\r\n     */\r\n    private fun captureVideo() : Boolean {\r\n        val videoCapture = this.videoCapture ?: return true\r\n\r\n        val curRecording = recording\r\n        if (curRecording != null) {\r\n            // Stop the current recording session.\r\n            curRecording.stop()\r\n            recording = null\r\n            return true\r\n        }\r\n\r\n        // create and start a new recording session\r\n        val name = SimpleDateFormat(FILENAME_FORMAT, Locale.US)\r\n            .format(System.currentTimeMillis())\r\n        val contentValues = ContentValues().apply {\r\n            put(MediaStore.MediaColumns.DISPLAY_NAME, name)\r\n            put(MediaStore.MediaColumns.MIME_TYPE, \"video/mp4\")\r\n\r\n            //put(MediaStore.Video.Media.RELATIVE_PATH, \"Movies/CameraX-Video\")\r\n            put(MediaStore.Video.Media.RELATIVE_PATH, \"DCIM/CameraAPIs\")\r\n        }\r\n\r\n        if(currFlashMode == FlashModes.ON) cameraControl.enableTorch(true)\r\n\r\n        val mediaStoreOutputOptions = MediaStoreOutputOptions\r\n            .Builder(contentResolver, MediaStore.Video.Media.EXTERNAL_CONTENT_URI)\r\n            .setContentValues(contentValues)\r\n            .build()\r\n        recording = videoCapture.output\r\n            .prepareRecording(this, mediaStoreOutputOptions)\r\n            .apply {\r\n                if (PermissionChecker.checkSelfPermission(this@MainActivity,\r\n                        Manifest.permission.RECORD_AUDIO) ==\r\n                    PermissionChecker.PERMISSION_GRANTED)\r\n                {\r\n                    withAudioEnabled()\r\n                }\r\n            }\r\n            .start(ContextCompat.getMainExecutor(this)) { recordEvent ->\r\n                when(recordEvent) {\r\n                    is VideoRecordEvent.Start -> {\r\n                        startRecording(true)\r\n                        inPause = false\r\n                    }\r\n                    is VideoRecordEvent.Finalize -> {\r\n                        if (!recordEvent.hasError()) {\r\n                            val msg = \"Video capture succeeded: \" + \"${recordEvent.outputResults.outputUri}\"\r\n                            if(currFlashMode == FlashModes.ON) { cameraControl.enableTorch(false) }\r\n                            //Toast.makeText(baseContext, msg, Toast.LENGTH_SHORT).show()\r\n                            Log.d(TAG, msg)\r\n                        } else {\r\n                            recording?.close()\r\n                            recording = null\r\n                            Log.e(TAG, \"Video capture ends with error: \" + \"${recordEvent.error}\")\r\n                            if(currFlashMode == FlashModes.ON) { cameraControl.enableTorch(false) }\r\n                        }\r\n                        startRecording(false)\r\n                        btTimer.visibility = View.VISIBLE   //rendo di nuovo visibile il pulsante del timer dopo la registrazione\r\n                    }\r\n                }\r\n            }\r\n        return true\r\n    }\r\n\r\n    /**\r\n     * Metodo per impostare la visuale durante la regisrazione\r\n     *\r\n     * @param status True se è stata avviata la registrazione;\r\n     *               False se è stata interrotta\r\n     */\r\n    private fun startRecording(status : Boolean)\r\n    {\r\n        val viewPH : Int\r\n        val viewVI : Int\r\n        isRecording = status\r\n        if(status){\r\n            viewPH = View.INVISIBLE\r\n            viewVI = View.VISIBLE\r\n\r\n            cmRecTimer.base = SystemClock.elapsedRealtime() // resetto il timer\r\n            cmRecTimer.start()\r\n\r\n            window.addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON) // mantiene lo schermo attivo durante la registrazione\r\n        }\r\n        else\r\n        {\r\n            viewPH = View.VISIBLE\r\n            viewVI = View.INVISIBLE\r\n            cmRecTimer.stop()\r\n\r\n            window.clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON) // permette allo schermo di spegnersi\r\n        }\r\n        recOptions() // cambio la grafica del pulsante\r\n\r\n        // nascondo/visualizzo\r\n        btRotation.visibility = viewPH\r\n        btGallery.visibility = viewPH\r\n        btZoom10.visibility = viewPH\r\n        btZoom05.visibility = viewPH\r\n\r\n        // visualizzo/nascondo\r\n        btZoomRec.visibility = viewVI\r\n        cmRecTimer.visibility = viewVI\r\n\r\n        // se inizio a registrare non posso più cambiare camera,\r\n        // quindi devo sistemare il valore della seekbar\r\n        if(status) {\r\n            sbZoom.progress = (zoomLv*sbZoom.max).toInt()\r\n        }\r\n        else\r\n        {\r\n            if(currentCamera==0 || currentCamera==3) // camere normali\r\n                sbZoom.progress = (zoomLv*(sbZoom.max - changeCameraSeekBar)).toInt() + changeCameraSeekBar\r\n            else // camere ultra grand angolari\r\n                sbZoom.progress = (zoomLv*sbZoom.max*0.54).toInt()\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Funzione per mettere in pausa o ripristinare la registrazione\r\n     */\r\n    private fun pauseVideo() {\r\n        // inPause = true se la registrazione è in pausa\r\n        if(inPause) {\r\n            recording?.resume() // ripristina registrazione\r\n            cmRecTimer.base = SystemClock.elapsedRealtime() - cmPauseAt // calcolo per riesumare il timer correttamente\r\n            cmRecTimer.start()\r\n            btPause.setBackgroundResource(R.drawable.pause_button) // cambio grafica al pulsante\r\n        }\r\n        else {\r\n            recording?.pause() // mette in pausa la registrazione\r\n            cmRecTimer.stop()\r\n            cmPauseAt = SystemClock.elapsedRealtime() - cmRecTimer.base\r\n            btPause.setBackgroundResource(R.drawable.play_button) // cambio grafica al pulsante\r\n        }\r\n        inPause = !inPause\r\n    }\r\n\r\n    /**\r\n     * Funzione per visualizzare i comandi corretti;\r\n     * Se sono in modalità foto il pulsante è bianco,\r\n     * se inizio a registrare (sempre in modalità foto) diventa rosso,\r\n     * se sono in modalità video e non sto registrando è bianco con pallino rosso;\r\n     * se sono in modalità video e sto registrando mostra i tasti per fermare e riprendere la registrazione\r\n     */\r\n    private fun recOptions()\r\n    {\r\n        btShoot.visibility = if(recordMode && isRecording) View.INVISIBLE else View.VISIBLE\r\n        findViewById<Group>(R.id.Group_rec).visibility = if(recordMode && isRecording) View.VISIBLE else View.INVISIBLE\r\n        // R.id.Group_rec è un gruppo contenente i pulsanti per fermare e riprendere la registrazione video\r\n\r\n        if(recordMode && !isRecording) // scelta del pulsante\r\n            btShoot.setBackgroundResource( R.drawable.in_recording_button)\r\n        else if(!recordMode)  {\r\n            if(isRecording)\r\n                btShoot.setBackgroundResource( R.drawable.rounded_corner_red)\r\n            else\r\n                btShoot.setBackgroundResource( R.drawable.rounded_corner)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Metodo per ricaricare i valori nel bundle o nelle preferences.\r\n     * Non è nel onCreate perchè usa variabili che vengono dichiarate nel startCamera\r\n     */\r\n    private fun loadFromBundle(savedInstanceState : Bundle?)\r\n    {\r\n        val preferences = getPreferences(MODE_PRIVATE)\r\n\r\n        // recupero le variabili dalle preferences\r\n        currentCamera = preferences.getInt(KEY_CAMERA,0)\r\n        val flashMode = preferences.getString(KEY_FLASH, \"OFF\")\r\n        val timerMode = preferences.getString(KEY_TIMER, \"OFF\")\r\n\r\n        while(currFlashMode.toString() != flashMode)\r\n            switchFlashMode()\r\n        setFlashMode()\r\n        while(currTimerMode.toString() != timerMode)\r\n            switchTimerMode()\r\n        setTimerMode()\r\n        var progress = changeCameraSeekBar\r\n\r\n        qrScanner = preferences.getBoolean(KEY_QRCODE, true)\r\n        qrCode(qrScanner)\r\n\r\n        if (savedInstanceState != null) { // controlo che ci sia il bundle\r\n            //recupero variabili dal bundle\r\n            currentCamera = savedInstanceState.getInt(KEY_CAMERA)\r\n            // se già ricaricato da preferences lo sovrascrivo,\r\n            // in quanto con preference salvo solo se è posteriore o anteriore\r\n            // mentre nel bundle salvo effettivamente la camera corretta\r\n            progress = savedInstanceState.getInt(KEY_ZOOM)\r\n            recordMode = savedInstanceState.getBoolean(KEY_REC)\r\n\r\n            sbZoom.progress = progress\r\n            changeZoom(progress, true) // cambio zoom e forzo il rebuild\r\n            changeMode(recordMode)\r\n        }\r\n        // uso changeZoom per cambiare lo zoom e ricostruire la camera\r\n        changeZoom(progress, true) // cambio zoom e forzo il rebuild\r\n    }\r\n\r\n    private fun loadFromSetting() {\r\n        val pm = PreferenceManager.getDefaultSharedPreferences(this)\r\n\r\n        // -- Impostazioni Tasti\r\n        volumeKey = pm.getString(\"LS_volumeKey\",\"zoom\")!!\r\n\r\n        // -- Foto\r\n\r\n        aspectRatioPhoto = when (pm.getString(\"LS_ratioPhoto\", \"3_4\")!!) {\r\n            \"3_4\" -> Rational(3, 4)\r\n            \"9_16\" -> Rational(9, 16)\r\n            \"1_1\" -> Rational(1, 1)\r\n            \"full\" -> {\r\n                val metrics = DisplayMetrics()\r\n                val display = windowManager.defaultDisplay\r\n                display.getRealMetrics(metrics)\r\n                Rational(metrics.widthPixels, metrics.heightPixels)\r\n            }\r\n            else -> Rational(4, 3) // Rapporto d'aspetto predefinito se nessun caso corrisponde\r\n        }\r\n\r\n        try {\r\n            imageCapture?.setCropAspectRatio(aspectRatioPhoto)\r\n        }\r\n        catch (e : Exception)\r\n        {\r\n            Log.e(TAG, \"[LoadFromSetting] $e\")\r\n        }\r\n\r\n        // -- Video\r\n        aspectRatioVideo = when (pm.getString(\"LS_ratioVideo\", \"3_4\")!!) {\r\n            \"3_4\" -> {\r\n                ratioVideo = AspectRatio.RATIO_4_3\r\n                Rational(3, 4)\r\n            }\r\n            else -> {\r\n                ratioVideo = AspectRatio.RATIO_16_9\r\n                Rational(9, 16)\r\n            }\r\n        }\r\n\r\n        videoResolution = when (pm.getString(\"LS_videoResolution\", \"UHD\")!!) {\r\n            \"UHD\" -> QualitySelector.from(Quality.HIGHEST)  // con il mio dispositivo non posso registrare in 4k a 4:3\r\n                                                            // quindi non metto Quality.UHD, altrimenti crasherebbe\r\n            \"FHD\" -> QualitySelector.from(Quality.FHD)\r\n            \"HD\" -> QualitySelector.from(Quality.HD)\r\n            else -> QualitySelector.from(Quality.SD)\r\n        }\r\n\r\n        createRecorder()\r\n\r\n        buildCamera()\r\n\r\n        changeMode(recordMode) // richiamo per cambiare la grandezza della preview\r\n\r\n        // -- Generali\r\n        findViewById<Group>(R.id.Group_grid).visibility =\r\n            if(pm.getBoolean(\"SW_grid\", true)) View.VISIBLE else View.INVISIBLE // le righe sono al interno di un gruppo, quindi prendo direttamente quello\r\n        hdr = pm.getBoolean(\"SW_HDR\", true)\r\n        gps = pm.getBoolean(\"SW_GPS\", true)\r\n        feedback = pm.getBoolean(\"SW_feedback\", true)\r\n\r\n\r\n    }\r\n\r\n    /**\r\n     * Metodo usato per cambiare lo zoom della camera\r\n     *\r\n     * @param progress  valore della SeekBar\r\n     * @param buildAnyway booleano per forzare il rebuild\r\n     */\r\n    private fun changeZoom(progress : Int, buildAnyway : Boolean = false)\r\n    {\r\n        var reBuild = false // evito di costruitr la camera ogni volta\r\n\r\n        // sbZoom va da 0 a 150, quindi i primi 50 valori sono per lo zoom con la ultra grand angolare,\r\n        // gli altri per la camera grand angolare, non sono riuscito a recoperare la telephoto\r\n        // valori corrispondenti a quale camara (Samsung S21)\r\n        // 0 -> back default;   grand angolare\r\n        // 1 -> front default;  ultra grand angolare\r\n        // 2 -> back;           ultra grand angolare\r\n        // 3 -> front;          grand angolare\r\n\r\n\r\n        if(isRecording) // se sto registrando, non posso cambiare camera, quindi c'è un valore di zoom diverso\r\n            zoomLv = progress/sbZoom.max.toFloat() // calcolo per ottenere un valore compreso ltra 0 e 1 per lo zoom\r\n        else\r\n        {\r\n            if(progress<changeCameraSeekBar) // sono sulle camere ultra grand angolari (changeCameraSeekBar = 50)\r\n            {\r\n                // sperimentalmente ho trovato che sul mio dispositivo (S21) al valore di zoomLv = 0.525 circa\r\n                // lo zoom della camera ultra grand angolare corrisponde al valore della camera principale a 1.0x\r\n                // quindi 2.14 = zoomLv*sbZoom.max/maxProgress = 0.525*200/49\r\n                zoomLv = (progress.toFloat()/sbZoom.max * 2.25f)\r\n                // calcolo per ottenere un valore tra 0 e 1 per lo zoom\r\n\r\n                if(currentCamera==0) // se sono in back default\r\n                {\r\n                    currentCamera = 2 // passo in back grand angolare\r\n                    reBuild=true\r\n                }\r\n                else if(currentCamera==3) // se sono in front normale\r\n                {\r\n                    currentCamera = 1 // passo in front grand angolare\r\n                    reBuild=true\r\n                }\r\n            }\r\n            else\r\n            {\r\n                zoomLv = (progress-changeCameraSeekBar)/(sbZoom.max - changeCameraSeekBar).toFloat()\r\n                // calcolo per ottenere un valore tra 0 e 1 per lo zoom\r\n                // è presente - changeCameraSeekBar perchè devo escultere i valori sotto changeCameraSeekBar\r\n                // quindi quando progress è a 50 (=changeCameraSeekBar) allora zoomLv deve essere 0\r\n                // mentre quando progress è a 150 (=sbZoom.max) allora zoomLv deve essere 1\r\n\r\n                if(currentCamera==2) // se sono in back grand angolare\r\n                {\r\n                    currentCamera = 0 // passo in back default\r\n                    reBuild=true\r\n                }\r\n                else if(currentCamera==1) // se sono in front grand angolare\r\n                {\r\n                    currentCamera = 3 // front in normale\r\n                    reBuild=true\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        val zoomState = camera.cameraInfo.zoomState\r\n        val maxzoom : Float = zoomState.value?.maxZoomRatio!!\r\n\r\n        btZoom05.text = getString(R.string.zoom_0_5x)\r\n        btZoom10.text = getString(R.string.zoom_1_0x)\r\n        btZoom05.backgroundTintList = getColorStateList(R.color.gray_onyx)\r\n        btZoom10.backgroundTintList = getColorStateList(R.color.gray_onyx)\r\n        btZoom05.setTextColor(getColor(R.color.white))\r\n        btZoom10.setTextColor(getColor(R.color.white))\r\n\r\n        if(currentCamera==0 || currentCamera == 3) // camera normale 1 -> 8\r\n        {\r\n            btZoomRec.text = \"${(zoomLv*(maxzoom-1)+1).toString().substring(0,3)}x\" // (zoomLv*(maxzoom-1)+1) fa si che visualizzi maxzoom come massimo e 1x come minimo\r\n            btZoom10.text = \"${(zoomLv*(maxzoom-1)+1).toString().substring(0,3)}x\"\r\n            btZoom10.backgroundTintList = getColorStateList(R.color.white)\r\n            btZoom10.setTextColor(getColor(R.color.black))\r\n        }\r\n        else // camera grand angolare 0.5 -> 8\r\n        {\r\n            btZoomRec.text = \"${(zoomLv*(maxzoom-0.5)+0.5).toString().substring(0,3)}x\" // (zoomLv*(maxzoom-0.5)+0.5) fa si che visualizzi maxzoom come massimo e 0.5x come minimo\r\n            btZoom05.text = \"${(zoomLv+0.5).toString().substring(0,3)}x\"\r\n            btZoom05.backgroundTintList = getColorStateList(R.color.white)\r\n            btZoom05.setTextColor(getColor(R.color.black))\r\n        }\r\n\r\n        if(buildAnyway || (reBuild && !isRecording)) // se sta registrando non cambia fotocamera\r\n            buildCamera()\r\n        cameraControl.setLinearZoom(zoomLv) // cambia il valore dello zoom\r\n        Log.d(TAG,\"Zoom lv: $zoomLv, zoomState: ${zoomState.value}\" )\r\n        Log.d(TAG, \"[current camera] - zoom: $currentCamera\")\r\n    }\r\n\r\n    /**\r\n     * Metodo per gestire il tocco dei pulsanti del volume\r\n     */\r\n    override fun dispatchKeyEvent(event: KeyEvent?): Boolean\r\n    {   // gestisco la registrazione video tenendo premuto il pulsante del volume per almeno 1 secondo e lo interrompo quando alzo il dito\r\n        if (event?.action == KeyEvent.ACTION_DOWN &&\r\n            (event.keyCode == KeyEvent.KEYCODE_VOLUME_UP || event.keyCode == KeyEvent.KEYCODE_VOLUME_DOWN)) {\r\n            when(volumeKey) {\r\n                \"zoom\" -> {\r\n                    // Volume_UP -> zoom in, Volume_DOWN -> zoom out\r\n                    sbZoom.incrementProgressBy(if (event.keyCode == KeyEvent.KEYCODE_VOLUME_UP) 1 else -1)\r\n                    return true\r\n                }\r\n                \"volume\" ->  return super.dispatchKeyEvent(event)\r\n            }\r\n            if(volumeTimer==null && volumeKey == \"shot\") {\r\n                if(event.keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) { // video tenendo premuto il pulsante per abbassare il volume\r\n                    volumeTimer = object: CountDownTimer(LONGCLICKDURATION, LONGCLICKDURATION) {\r\n                        override fun onTick(millisUntilFinished: Long) {\r\n                            // non fa nulla\r\n                        }\r\n\r\n                        override fun onFinish() {\r\n                            if(!isRecording) {\r\n                                var temporaryCountDown = countdown\r\n                                countdown = 0   // faccio partire direttamente il video, senza countdown\r\n                                timerShot(true)\r\n                                countdown = temporaryCountDown\r\n                            }\r\n                        }\r\n                    }\r\n                    volumeTimer?.start()\r\n                }\r\n                else {\r\n                    if(!recordMode) {\r\n                        countMultiShot = 0\r\n                        countDownText.visibility = View.VISIBLE\r\n                        captureJob = CoroutineScope(Dispatchers.Main).launch {\r\n                            while (isActive) {\r\n                                takePhoto()\r\n                                countDownText.text = \"${++countMultiShot}\"\r\n                                delay(500) // Intervallo tra i singoli scatti\r\n                                //if(feedback) it.performHapticFeedback(HapticFeedbackConstants.CONFIRM)\r\n                            }\r\n                        }\r\n                        return true\r\n                    }\r\n                }\r\n            }\r\n            return true\r\n        }\r\n        else if (event?.action == KeyEvent.ACTION_UP &&\r\n            (event.keyCode == KeyEvent.KEYCODE_VOLUME_UP || event.keyCode == KeyEvent.KEYCODE_VOLUME_DOWN)) {\r\n            volumeTimer?.cancel()   // fermo il timer quando sollevo il dito dal pulsante\r\n            volumeTimer = null\r\n            if(isRecording) {       // se sto registrando interrompo la registrazione\r\n                timerShot(true)\r\n                return true\r\n            }\r\n\r\n            // scatto da tocco singolo\r\n            when (volumeKey) {\r\n                \"shot\" -> {\r\n                    changeMode(event.keyCode == KeyEvent.KEYCODE_VOLUME_DOWN)\r\n                    timerShot(event.keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) // scatto una foto o inizio la registrazione di un video\r\n                    return true\r\n                }\r\n            }\r\n        }\r\n        return super.dispatchKeyEvent(event)\r\n    }\r\n\r\n\r\n    /**\r\n     * Funzione per switchare tra modalità Foto e Video;\r\n     * quindi cambia i pulsanti visualizzati\r\n     *\r\n     * @param record True se devo passare in modalità Video;\r\n     *                False se devo passare in modalità Foto\r\n     */\r\n    private fun changeMode(record : Boolean) {\r\n        recordMode = record\r\n        val bt1 = if(record) btRecMode else btPhotoMode\r\n        val bt2 = if(record) btPhotoMode else btRecMode\r\n        val aspect = if(record) aspectRatioVideo else aspectRatioPhoto\r\n\r\n        bt1.backgroundTintList = getColorStateList(R.color.white)\r\n        bt1.setTextColor(getColor(R.color.black))\r\n\r\n        //bt2.setBackgroundColor(getColor(R.color.gray_onyx))\r\n        bt2.backgroundTintList = getColorStateList(R.color.gray_onyx)\r\n        bt2.setTextColor(getColor(R.color.white))\r\n\r\n        // cambia rapporto preview\r\n        val layoutParams = viewPreview.layoutParams as ConstraintLayout.LayoutParams\r\n        layoutParams.dimensionRatio = \"H,${aspect.numerator}:${aspect.denominator}\" // Cambia l'aspect ratio desiderato qui\r\n        viewPreview.layoutParams = layoutParams\r\n\r\n\r\n        if(!timerOn) // se non c'è il timer attivato\r\n        {\r\n            if(!isRecording) // se non sta registrando\r\n                btShoot.setBackgroundResource( // cambio la grafica del pulsante in base a se sto registrando o no\r\n                    if(record) R.drawable.in_recording_button else R.drawable.rounded_corner\r\n                )\r\n            recOptions()\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Mi permette di ottenere l'inclinazione del dispositivo\r\n     */\r\n    private val orientationEventListener by lazy {\r\n        object : OrientationEventListener(this) {\r\n            override fun onOrientationChanged(orientation: Int) {\r\n                if (orientation == ORIENTATION_UNKNOWN) return\r\n\r\n                val rotation = when (orientation) {\r\n                    in 50 .. 130 -> 270\r\n                    in 140 .. 220 -> 180\r\n                    in 230 .. 310 -> 90\r\n                    in 0 .. 40,in 320 .. 360 -> 0\r\n                    else -> -1 // Angolo morto\r\n                }\r\n                // non ho messo valori multipli di 45 in modo da avere un minimo di gioco prima di cambiare rotazione\r\n                //Log.d(TAG,\"[orientation] $rotation\" )\r\n\r\n                if(!isRecording && rotation != -1 ) // gira solo se non sta registrando, per salvare i video nel orientamento iniziale\r\n                {\r\n                    rotateButton(rotation.toFloat())\r\n                    // Surface.ROTATION_0 è = 0, ROTATION_90 = 1, ... ROTATION_270 = 3, quindi = rotation/90\r\n                    videoCapture?.targetRotation = rotation/90\r\n                }\r\n                imageCapture?.targetRotation = rotation/90 // è fuori dal if, in questo modo l'immagine è sempre orientata correttamente\r\n            }\r\n        }\r\n    }\r\n\r\n    private inner class MyGestureListener : GestureDetector.SimpleOnGestureListener() {\r\n        private val TRESHOLD_VELOCITY : Float = 100.0f  // velocità minima per rilevare lo swipe\r\n        private val TRESHOLD : Float = 100.0f           // lunghezza minima del trascinamento per rilevare lo swipe\r\n        override fun onSingleTapUp(motionEvent: MotionEvent): Boolean {\r\n            when (motionEvent.action) {\r\n                MotionEvent.ACTION_UP -> {\r\n                    focusView.x = viewPreview.x - focusView.width / 2 + motionEvent.x\r\n                    focusView.y = viewPreview.y - focusView.height / 2 + motionEvent.y\r\n                    focusView.visibility = View.VISIBLE\r\n                    focusView.postDelayed(Runnable {\r\n                        focusView.visibility = View.INVISIBLE\r\n                    }, 1000)\r\n                    // Get the MeteringPointFactory from PreviewView\r\n                    val factory = viewBinding.viewPreview.meteringPointFactory\r\n\r\n                    // Create a MeteringPoint from the tap coordinates\r\n                    val point = factory.createPoint(motionEvent.x, motionEvent.y)\r\n\r\n                    // Create a MeteringAction from the MeteringPoint, you can configure it to specify the metering mode\r\n                    val action = FocusMeteringAction.Builder(point).build()\r\n\r\n                    // Trigger the focus and metering. The method returns a ListenableFuture since the operation\r\n                    // is asynchronous. You can use it get notified when the focus is successful or if it fails.\r\n                    cameraControl.startFocusAndMetering(action)\r\n                }\r\n            }\r\n            return true\r\n        }\r\n\r\n        override fun onFling(\r\n            e1: MotionEvent,\r\n            e2: MotionEvent,\r\n            velocityX: Float,\r\n            velocityY: Float\r\n        ): Boolean {\r\n            Log.d(TAG, \"CHIAMATA a onFling\")\r\n            val deltaY = e2.y - e1.y\r\n            val deltaX = e2.x - e1.x\r\n\r\n            if(abs(deltaX) < abs(deltaY))   // se trascino verso l'alto/basso\r\n            {\r\n                // swipe up-down\r\n                if(abs(deltaY) > TRESHOLD && abs(velocityY)>TRESHOLD_VELOCITY){\r\n                    rotateCamera()\r\n                    Log.d(TAG, \"SWIPE UP DETECTED\")\r\n                }\r\n            }\r\n            else if(abs(deltaX) > TRESHOLD && abs(velocityX)>TRESHOLD_VELOCITY){\r\n                if(deltaX>0 && recordMode)    // right swipe: video -> foto\r\n                {\r\n                    changeMode(false)\r\n                }\r\n                else if(deltaX<0 && !recordMode)    // left swipe: foto -> video\r\n                    changeMode(true)\r\n            }\r\n            return super.onFling(e1, e2, velocityX, velocityY)\r\n        }\r\n    }\r\n\r\n    private inner class ScaleGestureListener : ScaleGestureDetector.SimpleOnScaleGestureListener() {\r\n        override fun onScale(detector: ScaleGestureDetector): Boolean {\r\n            val scaleFactor = detector.scaleFactor\r\n            // Aggiorna lo zoom della fotocamera\r\n            Log.d(TAG, \"[zoom] $scaleFactor\")\r\n\r\n            if(scaleFactor>1) // se pinch in allora zoommo\r\n                sbZoom.incrementProgressBy(1) // cambio il valore della SeekBar che a sua volta cambia il valore dello zoom\r\n            else // altrimienti è pinch out e allora dezoommo\r\n                sbZoom.incrementProgressBy(-1)\r\n            return true\r\n        }\r\n    }\r\n\r\n    /**\r\n     * todo commento\r\n     */\r\n    private fun rotateCamera() { // id = 0 default back, id = 1 front default\r\n        if(currentCamera== 0 || currentCamera == 2)\r\n            currentCamera = 3 // passo in front, è la camera frontale grand angolare\r\n        else if(currentCamera==1 || currentCamera==3)\r\n            currentCamera = 0 // passo in back\r\n        sbZoom.progress = changeCameraSeekBar\r\n\r\n        if(!isRecording) // se sta registrando non cambia fotocamera\r\n            buildCamera()\r\n        Log.d(TAG, \"[current camera]  - rotate: $currentCamera\")\r\n    }\r\n\r\n    /**\r\n     * Metodo che permette di scattare una foto o di registrare un video a seconda del valore di record\r\n     *\r\n     * @param record True se in modalità video\r\n     *               False se in modalità foto\r\n     */\r\n    private fun timerShot(record : Boolean){\r\n        if(timerOn) { // se c'è il timer in funzione allora lo blocco\r\n            Log.d(TAG,\"Timer bloccato\")\r\n            timerOn = false\r\n            timer.cancel()\r\n            countDownText.visibility = View.INVISIBLE\r\n            findViewById<Group>(R.id.Group_extraFunc).visibility = View.VISIBLE\r\n            changeMode(recordMode)\r\n            return\r\n        }\r\n        if(isRecording && record){ // se sto già registrando e tengo premuto il pulsante rosso in modalità foto\r\n            // o premo il pulsante per fermare in modalità vidoe\r\n            captureVideo() // lo richiamo per fermare la registraizone\r\n            return\r\n        }\r\n        if (isRecording && !record){ // se sto già registrando e premo il pulsante rosso in moodalità foto\r\n            // scatta una foto senza usare il timer\r\n            takePhoto()\r\n            return\r\n        }\r\n\r\n        timerOn = true\r\n        timer = object : CountDownTimer(countdown*1000, 1000){\r\n            override fun onTick(remainingMillis: Long) {\r\n                //btTimer.visibility = View.INVISIBLE //rendo invisibile il pulsante del timer durante il countdown\r\n                findViewById<Group>(R.id.Group_extraFunc).visibility = View.INVISIBLE\r\n                btShoot.setBackgroundResource(R.drawable.rounded_stop_button)\r\n                countDownText.text = \"${remainingMillis/1000 + 1}\"\r\n                countDownText.visibility = View.VISIBLE\r\n                Log.d(TAG, \"Secondi rimanenti: \"+remainingMillis/1000)\r\n            }\r\n            override fun onFinish() {\r\n                timerOn = false\r\n                countDownText.visibility = View.INVISIBLE\r\n                findViewById<Group>(R.id.Group_extraFunc).visibility = View.VISIBLE\r\n                if(record)\r\n                    captureVideo()\r\n                else\r\n                    takePhoto()\r\n                changeMode(recordMode)\r\n            }\r\n\r\n        }.start()\r\n        Log.d(TAG, \"Secondi ristabiliti: $countdown\")\r\n    }\r\n\r\n    /**\r\n     * Ruoto i pulsanti per far si che siano dritti\r\n     *\r\n     * @param angle è il numero di gradi per ruotare i tasti\r\n     */\r\n    private fun rotateButton(angle : Float)\r\n    {\r\n        btGallery.rotation = angle\r\n        btRotation.rotation = angle\r\n        btFlash.rotation = angle\r\n        btTimer.rotation = angle\r\n        btZoom05.rotation = angle\r\n        btZoom10.rotation = angle\r\n        btZoomRec.rotation = angle\r\n        cmRecTimer.rotation = angle\r\n        btRecMode.rotation = angle\r\n        btPhotoMode.rotation = angle\r\n    }\r\n\r\n    /**\r\n     * TODO: da commentare\r\n     */\r\n    private fun switchTimerMode() {\r\n        currTimerMode = TimerModes.next(currTimerMode)\r\n        setTimerMode()\r\n        setTimerIcon(currTimerMode.text)\r\n    }\r\n\r\n    /**\r\n     * TODO: da commentare\r\n     */\r\n    private fun selectTimerMode(ordinal: Int?): Boolean{\r\n        if(ordinal == null) {\r\n            throw IllegalArgumentException()\r\n        }\r\n        currTimerMode = TimerModes.values()[ordinal]\r\n        setTimerMode()\r\n        setTimerIcon(currTimerMode.text)\r\n        return true\r\n    }\r\n\r\n    /**\r\n     * TODO: da commentare\r\n     */\r\n    private fun setTimerMode(){\r\n        countdown = when(currTimerMode){\r\n            TimerModes.OFF -> 0\r\n            TimerModes.ON_3 -> 3\r\n            TimerModes.ON_5 -> 5\r\n            TimerModes.ON_10 -> 10\r\n        }\r\n    }\r\n\r\n    /**\r\n     * TODO: da commentare\r\n     */\r\n    private fun setTimerIcon(status : String){\r\n        btTimer.backgroundTintList = getColorStateList(R.color.aureolin_yellow)\r\n        btTimer.setBackgroundResource(\r\n            when(status){\r\n                \"OFF\" -> {\r\n                    btTimer.backgroundTintList = getColorStateList(R.color.white)\r\n                    R.drawable.timer_0\r\n                }\r\n                \"3\" -> R.drawable.timer_3\r\n                \"5\" -> R.drawable.timer_5\r\n                else -> R.drawable.timer_10\r\n            }\r\n        )\r\n    }\r\n\r\n\r\n    /**\r\n     * Metodo per passare alla prossima modalità del flash, nell'ordine:\r\n     *  - OFF\r\n     *  - ON\r\n     *  - AUTO\r\n     */\r\n    private fun switchFlashMode() {\r\n        currFlashMode = FlashModes.next(currFlashMode)\r\n        setFlashMode()\r\n    }\r\n\r\n    /**\r\n     * Metodo per cambiare [currFlashMode]\r\n     */\r\n    private fun selectFlashMode(ordinal: Int?): Boolean {\r\n        if(ordinal == null) {\r\n            throw IllegalArgumentException()\r\n        }\r\n        currFlashMode = FlashModes.values()[ordinal]\r\n        setFlashMode()\r\n        return true\r\n    }\r\n\r\n    /**\r\n     * Metodo che permette di imposta la modalità del flash specificata da [currFlashMode]\r\n     */\r\n    private fun setFlashMode() {\r\n        when(currFlashMode) {\r\n            FlashModes.OFF -> {\r\n                btFlash.setBackgroundResource(R.drawable.flash_off)\r\n                btFlash.backgroundTintList = getColorStateList(R.color.white)\r\n                imageCapture?.flashMode = ImageCapture.FLASH_MODE_OFF\r\n                //Nel caso in cui si stia registrando disattiva il flash in modalità OFF\r\n                if(recording != null) { cameraControl.enableTorch(false) }\r\n            }\r\n            FlashModes.ON -> {\r\n                btFlash.setBackgroundResource(R.drawable.flash_on)\r\n                btFlash.backgroundTintList = getColorStateList(R.color.aureolin_yellow)\r\n                imageCapture?.flashMode = ImageCapture.FLASH_MODE_ON\r\n                //Nel caso in cui si stia registrando attiva il flash in modalità ON\r\n                if(recording != null) { cameraControl.enableTorch(true) }\r\n            }\r\n            FlashModes.AUTO -> {\r\n                btFlash.setBackgroundResource(R.drawable.flash_auto)\r\n                btFlash.backgroundTintList = getColorStateList(R.color.aureolin_yellow)\r\n                imageCapture?.flashMode = ImageCapture.FLASH_MODE_AUTO\r\n                //Nel caso in cui si stia registrando disattiva il flash in modalità AUTO\r\n                if(recording != null) { cameraControl.enableTorch(false) }\r\n            }\r\n        }\r\n    }\r\n\r\n    /* TODO: guardare se serve\r\n    private class LuminosityAnalyzer(private val listener: LumaListener) : ImageAnalysis.Analyzer {\r\n\r\n        private fun ByteBuffer.toByteArray(): ByteArray {\r\n            rewind()    // Rewind the buffer to zero\r\n            val data = ByteArray(remaining())\r\n            get(data)   // Copy the buffer into a byte array\r\n            return data // Return the byte array\r\n        }\r\n\r\n        override fun analyze(image: ImageProxy) {\r\n\r\n            val buffer = image.planes[0].buffer\r\n            val data = buffer.toByteArray()\r\n            val pixels = data.map { it.toInt() and 0xFF }\r\n            val luma = pixels.average()\r\n\r\n            listener(luma)\r\n\r\n            image.close()\r\n        }\r\n    } */\r\n\r\n    /**\r\n     * abilita il \"sensore\" per l'angolo\r\n     */\r\n    override fun onStart() {\r\n        super.onStart()\r\n        orientationEventListener.enable()\r\n    }\r\n\r\n    /**\r\n     * disabilita il \"sensore\" per l'angolo\r\n     */\r\n    override fun onStop() {\r\n        super.onStop()\r\n        orientationEventListener.disable()\r\n    }\r\n\r\n    /**\r\n     * quando l'applicazione viene messa in background salvo le preference\r\n     * da ripristinare al avvio, anche se viene completamente chiusa\r\n     *\r\n     * Ho deciso di non salvare tutti i dati, quindi escludo lo zoom\r\n     * e anche la modalità in cui viene lasciata\r\n     */\r\n    override fun onPause()\r\n    {\r\n        super.onPause()\r\n\r\n        // Store values between instances here\r\n        val preferences = getPreferences(MODE_PRIVATE)\r\n        val editor = preferences.edit()\r\n\r\n        if(currentCamera%2==0) // a differenza di onSaveInstanceState non salvo lo zoom e la camera corretta\r\n        // salvo solo se è frontale o posteriore\r\n            editor.putInt(KEY_CAMERA, 0)\r\n        else\r\n        {\r\n            if(availableCameraInfos.size == 4)\r\n                editor.putInt(KEY_CAMERA, 3)\r\n            else\r\n                editor.putInt(KEY_CAMERA, 1)\r\n        }\r\n        editor.putString(KEY_FLASH, currFlashMode.toString())\r\n        editor.putString(KEY_TIMER, currTimerMode.toString())\r\n        editor.putBoolean(KEY_QRCODE, qrScanner)\r\n\r\n        editor.apply()\r\n\r\n        window.clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)\r\n    }\r\n\r\n    /**\r\n     * Ripristino lo zoom\r\n     */\r\n    override fun onResume()\r\n    {\r\n        super.onResume()\r\n        Log.d(TAG, \"onResume\")\r\n        try { // il lifecycle dello zoom viene chiso con la chiusura dell'app,\r\n            // e non viene ripristinato manualmente, quindi chiamo changeZoom\r\n            // con il valore sbZoom.progress che è ancora salvato\r\n            // Se invece l'applicazione va in background e viene killata da android\r\n            // allora changeZoom(sbZoom.progress) restituisce errore che non è\r\n            // necessario gestire, in quel caso allora i dati sono stati salvati dul Bundle\r\n            // e ripristinati da loadFromBundle, se invece viene killata dal utente\r\n            // allora non viene ripristinato lo stato\r\n            changeZoom(sbZoom.progress)\r\n        }\r\n        catch (e : Exception) {\r\n            Log.e(TAG, \"Exception $e\")\r\n        }\r\n\r\n        loadFromSetting()\r\n    }\r\n\r\n    /**\r\n     * salvo la camera corrente (a differenza delle preference in cui salvo solo\r\n     * se è anteriore o posteriore, lo zoom e la modalità\r\n     */\r\n    override fun onSaveInstanceState(savedInstanceState: Bundle) {\r\n        super.onSaveInstanceState(savedInstanceState)\r\n        savedInstanceState.putInt(KEY_CAMERA, currentCamera)\r\n        savedInstanceState.putInt(KEY_ZOOM, sbZoom.progress)\r\n        savedInstanceState.putBoolean(KEY_REC, recordMode)\r\n    }\r\n\r\n    /**\r\n     * TODO: boohhh\r\n     */\r\n    override fun onDestroy() {\r\n        super.onDestroy()\r\n        cameraExecutor.shutdown()\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/unipd/cameraapis/MainActivity.kt b/app/src/main/java/com/unipd/cameraapis/MainActivity.kt
--- a/app/src/main/java/com/unipd/cameraapis/MainActivity.kt	(revision c5b2c0d6a946c923406dc2cf75102b84d5fc6160)
+++ b/app/src/main/java/com/unipd/cameraapis/MainActivity.kt	(date 1686298052481)
@@ -2,6 +2,7 @@
 
 import android.Manifest
 import android.app.Activity
+import android.app.AlertDialog
 import android.content.ContentValues
 import android.content.Context
 import android.content.Intent
@@ -35,6 +36,7 @@
 import android.widget.SeekBar
 import android.widget.TextView
 import android.widget.Toast
+import androidx.activity.result.ActivityResultLauncher
 import androidx.activity.result.contract.ActivityResultContracts
 import androidx.appcompat.app.AppCompatActivity
 import androidx.camera.core.AspectRatio
@@ -61,6 +63,8 @@
 import androidx.core.content.ContextCompat
 import androidx.core.content.PermissionChecker
 import androidx.preference.PreferenceManager
+import com.journeyapps.barcodescanner.ScanContract
+import com.journeyapps.barcodescanner.ScanOptions
 import com.unipd.cameraapis.databinding.ActivityMainBinding
 import kotlinx.coroutines.CoroutineScope
 import kotlinx.coroutines.Dispatchers
@@ -160,6 +164,7 @@
     private val showPopUp = PopUpFragment()
     private var popUpVisible = false
     private var permissionDenyAsk = false
+    private lateinit var qrCodeLauncher: ActivityResultLauncher<ScanOptions>
 
     companion object {
 
@@ -340,6 +345,16 @@
         gestureDetector = GestureDetector(this, MyGestureListener())
         scaleGestureDetector = ScaleGestureDetector(this, ScaleGestureListener())
 
+        qrCodeLauncher = registerForActivityResult(ScanContract()) { result ->
+            if (result.contents != null) {
+                Log.d(TAG, "Contenuto del QR code: ${result.contents}")
+                val builder: AlertDialog.Builder = AlertDialog.Builder(this@MainActivity)
+                builder.setTitle("Result")
+                builder.setMessage(result.contents)
+
+            }
+        }
+
     }
 
     /**
@@ -470,7 +485,6 @@
             true
         })
 
-
         // listener per il pulsante QR
         btQR.setOnClickListener {
             qrScanner = !qrScanner
@@ -479,13 +493,14 @@
             //Todo: butta dentro QrCode plz, che lo richiamo dal loadBundle
             //Todo: inoltre prima di mostrare risultati contollare che il timer sia disattivato, -> "timerOn"
 
-            /*
-            val intentIntegrator = IntentIntegrator(this)
-            intentIntegrator.setDesiredBarcodeFormats(IntentIntegrator.QR_CODE)
-            intentIntegrator.setOrientationLocked(true)
-            intentIntegrator.setPrompt("Scanning")
-            intentIntegrator.initiateScan()
-            */
+            val scanOptions: ScanOptions = ScanOptions()
+            scanOptions.setPrompt("Scan a QR code")
+            scanOptions.setBeepEnabled(false)
+            scanOptions.setOrientationLocked(false)
+            scanOptions.setCaptureActivity(ScannerCaptureActivity::class.java)
+            Log.d(TAG, "Scansione iniziata")
+            qrCodeLauncher.launch(scanOptions)
+            Log.d(TAG, "Scansione Terminata")
 
         }
 
@@ -495,6 +510,8 @@
 
     }
 
+
+
     private fun qrCode(status: Boolean)
     {
         if(status)
@@ -1010,6 +1027,7 @@
     {   // gestisco la registrazione video tenendo premuto il pulsante del volume per almeno 1 secondo e lo interrompo quando alzo il dito
         if (event?.action == KeyEvent.ACTION_DOWN &&
             (event.keyCode == KeyEvent.KEYCODE_VOLUME_UP || event.keyCode == KeyEvent.KEYCODE_VOLUME_DOWN)) {
+            isVolumeButtonClicked = true
             when(volumeKey) {
                 "zoom" -> {
                     // Volume_UP -> zoom in, Volume_DOWN -> zoom out
@@ -1037,25 +1055,29 @@
                     volumeTimer?.start()
                 }
                 else {
-                    if(!recordMode) {
+                        changeMode(false)
                         countMultiShot = 0
                         countDownText.visibility = View.VISIBLE
                         captureJob = CoroutineScope(Dispatchers.Main).launch {
-                            while (isActive) {
+                            while (isVolumeButtonClicked) {
                                 takePhoto()
                                 countDownText.text = "${++countMultiShot}"
-                                delay(500) // Intervallo tra i singoli scatti
-                                //if(feedback) it.performHapticFeedback(HapticFeedbackConstants.CONFIRM)
+                                delay(300) // Intervallo tra i singoli scatti
+                                //if(feedback) it.performHapticFeedback(HapticFeedbackConstants.CONFIRM)+
                             }
                         }
-                        return true
-                    }
                 }
             }
             return true
         }
         else if (event?.action == KeyEvent.ACTION_UP &&
             (event.keyCode == KeyEvent.KEYCODE_VOLUME_UP || event.keyCode == KeyEvent.KEYCODE_VOLUME_DOWN)) {
+            captureJob?.cancel()
+            captureJob = null
+            countDownText.postDelayed(Runnable {
+                countDownText.visibility = View.INVISIBLE
+            }, 1000)
+            isVolumeButtonClicked = false
             volumeTimer?.cancel()   // fermo il timer quando sollevo il dito dal pulsante
             volumeTimer = null
             if(isRecording) {       // se sto registrando interrompo la registrazione
Index: app/build.gradle
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>plugins {\r\n    id 'com.android.application'\r\n    id 'org.jetbrains.kotlin.android'\r\n}\r\n\r\nandroid {\r\n    namespace 'com.unipd.cameraapis'\r\n    compileSdk 33\r\n\r\n    defaultConfig {\r\n        applicationId \"com.unipd.cameraapis\"\r\n        minSdk 31\r\n        targetSdk 33\r\n        versionCode 1\r\n        versionName \"1.0\"\r\n\r\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\r\n    }\r\n\r\n    buildFeatures {\r\n        viewBinding true\r\n    }\r\n\r\n    buildTypes {\r\n        release {\r\n            minifyEnabled false\r\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\r\n        }\r\n    }\r\n    compileOptions {\r\n        sourceCompatibility JavaVersion.VERSION_1_8\r\n        targetCompatibility JavaVersion.VERSION_1_8\r\n    }\r\n    kotlinOptions {\r\n        jvmTarget = '1.8'\r\n    }\r\n}\r\n\r\ndependencies {\r\n\r\n    implementation 'androidx.core:core-ktx:1.10.1'\r\n    implementation 'androidx.appcompat:appcompat:1.6.1'\r\n    implementation 'com.google.android.material:material:1.9.0'\r\n    implementation 'androidx.constraintlayout:constraintlayout:2.1.4'\r\n    implementation 'androidx.preference:preference:1.2.0'\r\n    testImplementation 'junit:junit:4.13.2'\r\n    androidTestImplementation 'androidx.test.ext:junit:1.1.5'\r\n    androidTestImplementation 'androidx.test.espresso:espresso-core:3.5.1'\r\n\r\n    //CameraX\r\n    def camerax_version = \"1.3.0-alpha06\"\r\n    implementation \"androidx.camera:camera-core:${camerax_version}\"\r\n    implementation \"androidx.camera:camera-camera2:${camerax_version}\"\r\n    implementation \"androidx.camera:camera-lifecycle:${camerax_version}\"\r\n    implementation \"androidx.camera:camera-video:${camerax_version}\"\r\n    implementation \"androidx.camera:camera-view:${camerax_version}\"\r\n    implementation \"androidx.camera:camera-mlkit-vision:${camerax_version}\"\r\n    implementation \"androidx.camera:camera-extensions:${camerax_version}\"\r\n\r\n    // To use RoleManagerCompat\r\n    implementation \"androidx.core:core-role:1.0.0\"\r\n\r\n    // To use the Animator APIs\r\n    implementation 'androidx.core:core-animation:1.0.0-beta01'\r\n    // To test the Animator APIs\r\n    androidTestImplementation \"androidx.core:core-animation-testing:1.0.0-alpha02\"\r\n\r\n    // QR code\r\n    implementation 'com.journeyapps:zxing-android-embedded:4.2.0'\r\n    implementation 'androidx.appcompat:appcompat:1.3.1'\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/build.gradle b/app/build.gradle
--- a/app/build.gradle	(revision c5b2c0d6a946c923406dc2cf75102b84d5fc6160)
+++ b/app/build.gradle	(date 1686243884845)
@@ -66,7 +66,7 @@
     androidTestImplementation "androidx.core:core-animation-testing:1.0.0-alpha02"
 
     // QR code
-    implementation 'com.journeyapps:zxing-android-embedded:4.2.0'
+    implementation 'com.journeyapps:zxing-android-embedded:4.3.0'
     implementation 'androidx.appcompat:appcompat:1.3.1'
 
 }
Index: app/src/main/java/com/unipd/cameraapis/ScannerCaptureActivity.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/unipd/cameraapis/ScannerCaptureActivity.kt b/app/src/main/java/com/unipd/cameraapis/ScannerCaptureActivity.kt
new file mode 100644
--- /dev/null	(date 1686244185070)
+++ b/app/src/main/java/com/unipd/cameraapis/ScannerCaptureActivity.kt	(date 1686244185070)
@@ -0,0 +1,6 @@
+package com.unipd.cameraapis
+
+import com.journeyapps.barcodescanner.CaptureActivity
+
+class ScannerCaptureActivity: CaptureActivity() {
+}
\ No newline at end of file
